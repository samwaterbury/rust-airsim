# AirLib for Rust

Rust bindings for the [AirSim project](https://github.com/microsoft/AirSim)'s `AirLib` C++ library.

## Overview

AirSim is an open source simulator for autonomous vehicles. At its core is a standalone C++ library called `AirLib` which does not depend on the Unreal or Unity game engines.

The goal of `rust-airsim` is to provide useful Rust bindings for the `AirLib` library. This is done primarily using [cxx](https://github.com/dtolnay/cxx) and [autocxx](https://github.com/google/autocxx).

## Status ⚠️

This project is _extremely_ incomplete and only barely usable. It was, frankly, a bit of a longshot for a few reasons:

1. AirSim's architecture makes heavy use of classes and object-oriented patterns
2. The ecosystem for C++ interop is still very green (although it is advancing by leaps and bounds with projects like [cxx](https://github.com/dtolnay/cxx) and [autocxx](https://github.com/google/autocxx))

In its current state, the `airlib` crate is not ready for consumption but may be useful as a launching point if anyone else wants to try their hand at using AirSim with Rust in the future.

I'm pivoting my simulation endeavors a bit and likely won't be continuing to work on this project. However, I am more than happy to help anyone who discovers this down the road, so feel free to reach out!

## How to Build

First, clone the repository and initialize the AirSim submodule:

```sh
git clone --recurse-submodules git@github.com:samwaterbury/rust-airsim.git
```

Next, `cd AirSim` and build the C++ library by following the [AirSim documentation](https://microsoft.github.io/AirSim/#how-to-get-it).

Once that's finished, you can build the crate with the usual `cargo build`.

## Documentation

You can build the documentation with:

```sh
cargo doc --document-private-items --open
```

The reason `--document-private-items` is necessary seems to be a quirk of how the autogenerated `ffi` module is structured. It looks something like this (abbreviated):

```rust
mod ffi {
    mod bindgen {
        pub(super) mod root {
            pub mod msr {
                pub mod airlib {
                    #[repr(C, packed)]
                    pub struct SomeStruct {
                        do_not_attempt_to_allocate_nonpod_types: [*const u8; 0],
                        _pinned: core::marker::PhantomData<core::marker::PhantomPinned>,
                    }
                    impl SomeStruct {
                        pub fn some_function() -> cxx::UniquePtr<root::msr::airlib::SomeStruct> {
                            cxxbridge::some_function_autocxx_wrapper()
                        }
                    }
                }
            }
        }
    }

    #[cxx::bridge]
    mod cxxbridge {
        unsafe extern "C++" {
            #[namespace = "msr::airlib"]
            type SomeStruct = super::bindgen::root::msr::airlib::SomeStruct;
        }
    }

    use bindgen::root;
    pub mod msr {
        pub mod airlib {
            pub use super::super::cxxbridge::SomeStruct;
        }
    }
}
```

It seems that `rustdoc` documents `ffi::msr::airlib::SomeStruct` (at the bottom) but not `some_function` (in the `bindgen::` module) despite it being publicly accessible from outside the crate.

The extent of my working hypothesis is that this issue stems from the interaction between the `msr::airlib::` C++ namespace and the way `autocxx` generates this module.
